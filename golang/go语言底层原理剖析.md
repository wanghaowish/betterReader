# go语言底层原理剖析

## go语言编译器

go编译器阶段：词法解析→语法解析→抽象语法树构建→类型检查→变量捕获→函数内联→**逃逸分析**→闭包重写→遍历并编译函数→SSA生成→机器码生成

编译器可以对代码进行一定程度的优化

#### 逃逸分析

逃逸分析是用于标识变量内存应该分配在栈还是堆。函数执行完成后，栈会被销毁，当继续访问被销毁栈上的对象指针，就会产生逃逸。

常见的内存逃逸场景：

- **在方法内将局部变量指针返回。**局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或者带指针的值到channel中。**在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- **在一个切片存储指针或者带指针的值。**一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在interface上调用方法。**在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。
## 浮点数

fmt包打印浮点数核心是调用标准库的strconv.FormatFloat函数。

| 占位符 | 说明                                                   |
| :----: | ------------------------------------------------------ |
|   %b   | 无小数部分、二进制指数的科学计数法，如-123456p-78      |
|   %E   | 科学计数法，如-1234.456e+78                            |
|   %e   | 科学计数法，如-1234.456E+78                            |
|   %f   | 有小数部分但无指数部分，如123.456                      |
|   %F   | 等价于%f                                               |
|   %g   | 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） |
|   %G   | 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） |

shopspring/decimal 第三方库，在处理货币方面有一定优势

## 类型推断

`:=`用于变量的类型推断。类型推断依赖于编译器的处理能力。

## 常量与隐式类型转换

const关键字声明常量，声明时可以指定或者忽略类型。等号左边的叫命名常量，等号右边的叫未命名常量，未命名常量只会在编译期间存在，因此不会存在在内存中。命名常存在内存静态只读区， 不能被修改。go语言禁止对常量进行取地址操作。

隐式类型转换的规则是有类型常量优先于无类型。无 类型常量运算时的优先级为：复数(Imag)>浮点数(float)>符文数(rune)>整数(int)

## 字符串的本质与实现

go语言中字符常量存储于静态编译区，字符串不能被修改，只能被访问。字符串本质是一个定长的字符数组。字符常量的拼接发生在编译时，字符串常量的拼接发生在运行时。字节数组和字符串的相互转换并不是无损的指针引用，而是涉及了复制。

字符串的struct：

```go
type StringHeader struct{
    Data uintptr //指向底层的字符数组
    Len int //代表字符串的长度
}
```

字母占据1个字节，中文一般占据3个字节。strings库内包含很多字符处理函数。strconv包含很多字符串转换的函数。``可以换行，""不能换行。字符串拼接的原理并不是简单的将一个字符串合并到另一个字符串中，而是找一个更大的空间，通过内存复制的形式将字符串复制到其中。

## 数组

三种声明方式

```go
var arr [3]int
var arr2 =[3]int{1,2,3}
arr3:=[...]int{1,2,3} //语法糖 ... 这种声明方式在编译时自动推断长度
```

数组在赋值和函数调用时的形参都是值复制。数组在编译时会进行重要的优化，当数组长度小于4时，运行时数组会被放置在栈中，大于4则会放在内存的静态只读区。数组一般在Go语言中比较少用。

## 切片

切片相对于数组而言在Go中更常用。切片是长度可变的序列，序列中的每个元素都有相同的类型。它和数组不同的是切片不需要指定长度。切片是一种轻量级的数据结构，提供了访问数组任意元素的功能。

```go
type SliceHeader struct{
    Data uintptr
    Len int
    Cap int
}
```

指针指向切片元素对应的底层数组元素的地址。len对应切片中元素的数目，长度不能超过cap。容量一般是从切片的开始位置到底层数据的结束位置的长度。

### 切片的初始化

切片的初始化需要用到make函数。可通过make函数指定长度和容量，不指定容量的情况下默认容量等于长度。使用数组创建slice时slice和原数组共用一部分内存。

![img](https://raw.githubusercontent.com/wanghaowish/picGo/main/img/202207191423469.png)

```go
//nil切片
var slice []int
//空切片
silce := make( []int , 0 )
slice := []int{ }
```

![img](https://raw.githubusercontent.com/wanghaowish/picGo/main/img/202207191423045.png)

空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。

### 切片的截取

切片和数组一样，切片中的数据仍然是内存中的一片连续区域。截取切片可以通过下标的方式来截断。被截断后的切片长度跟容量都发生了变化。被截取后的切片仍然指向原始切片的底层数据。

### 切片复制和数据引用

数组的复制是值复制，修改复制后的数组不会影响原数组，但是修改复制后的切片会影响原切片。切片的复制其实也是值复制，只不过这里复制的值是指对于运行时SliceHeader结构的进行复制。底层指针仍然指向相同的底层数据的数组地址。

### 切片的扩缩容

append函数可以添加新元素到切片的末尾，它可以接受可变长度的元素，并且可以自动扩容。

切片的扩容策略：

如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。上面那个例子也验证了这一情况，总容量从原来的4个翻倍到现在的8个。

一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。

注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。

删除切片的某个元素的话直接使用截取即可。

```go
a:=int(len(numbers)/2)
numbers:=append(numbers[:a],numbers[a+1:]...)
```



## 哈希表

## 函数和栈

## defer的延迟调用

## 异常和异常捕获

## 接口和程序设计模式

## 反射

## 协程初探

## 协程设计和调度原理

## 通道和协程通信

## 并发

## 内存分配管理

## 垃圾回收（GC）初探

## 深入垃圾回收全流程

## 调试：特征分析和事件追踪

