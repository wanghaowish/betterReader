# 面试总结

## go

### 内存逃逸

golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。

常见的内存逃逸场景：

- **在方法内将局部变量指针返回。**局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或者带指针的值到channel中。**在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- **在一个切片存储指针或者带指针的值。**一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在interface上调用方法。**在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

### GPM原理

之前的goroutine调度器是没有P的。M每次创建、调度、销毁G都要获取锁，形成了激烈的锁竞争；M 转移 G 会造成延迟和额外的系统负载；系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。

G：goroutine协程

P：processor处理器

M:：machine工作线程

go关键字会创建一个G，G优先保存到P的本地队列中，如果P的本地队列满了，则会保存到全局队列。M获取到P之后，会从P的本地队列弹出一个G执行，如果P的本地队列是空的，就从全局队列获取。如果全局队列获取不到，就会从其他的MP组合中偷取G过来执行。G如果创建了G'，是优先保存到同一个P的队列中的。如果M执行过程中G阻塞了，runtime就会将M跟P剥离，M进入休眠，获取其他的空闲线程或者创建线程来服务这个P。

GPM的调度策略：

- 复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
  
    1）work stealing 机制
    
     当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。
    
    2）hand off 机制
    
     当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。
    
- 利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。
- 抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。
- 全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。

### GC回收

常用的回收算法：

- 引用计数：每个对象维护一个引用计数，当被引用对象被创建或被赋值给其他对象时引用计数自动加 +1；如果这个对象被销毁，则计数 -1 ，当计数为 0 时，回收该对象。
    - 优点：对象可以很快被回收，不会出现内存耗尽或到达阀值才回收。
    - 缺点：不能很好的处理循环引用
- 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记“被引用”，没有被标记的则进行回收。
    - 优点：解决了引用计数的缺点。
    - 缺点：需要 STW（stop the world），暂时停止程序运行。
- 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。
    - 优点：回收性能好
    - 缺点：算法复杂

### 三色标记法

- 0初始状态下所有对象都是白色的。
- 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
- 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
- 循环步骤3，直到灰色对象全部变黑色。
- 通过写屏障(write-barrier)检测对象有变化，重复以上操作
- 收集所有白色对象（垃圾）

### 写屏障：

为了避免GC的过程中新修改的引用关系到GC的结果发生错误，我们需要进行STW。但是STW会影响程序的性能，所以我们要通过写屏障技术尽可能地缩短STW的时间。

写屏障破坏两个条件其一即可

- 破坏条件1：Dijistra写屏障

满足强三色不变性：黑色节点不允许引用白色节点 当黑色节点新增了白色节点的引用时，将对应的白色节点改为灰色

- 破坏条件2：Yuasa写屏障

满足弱三色不变性：黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用（确保不会被遗漏） 当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色

### STW（stop the world）

为了避免在 GC 的过程中，对象之间的引用关系发生新的变更，使得GC的结果发生错误（如GC过程中新增了一个引用，但是由于未扫描到该引用导致将被引用的对象清除了），停止所有正在运行的协程。Golang目前已经可以做到1ms以下的STW。

### CSP模型

CSP 模型是“以通信的方式来共享内存”，不同于传统的多线程通过共享内存来通信。用于描述两个独立的并发实体通过共享的通讯 channel (管道)进行通信的并发模型。

### waitgroup使用场景

实现goroutine的同步，并发控制。可以设置最大goroutine数。

- Add(delta int)：增加/减少若干计数
- Done：减少 1 个计数，等价于 **Add(-1)**
- Wait：卡住，直到计数等于 0

### make和new的区别

Go语言中new和make都是用来内存分配的。简单的说，new只分配内存，make用于slice，map，和channel的初始化。

- make和new都是golang用来分配内存的，且在堆上分配内存，make 即分配内存，也初始化内存。new只是将内存清零，并没有初始化内存。
- make返回的还是引用类型本身；而new返回的是指向类型的指针。
- make只能用来分配及初始化类型为slice，map，channel的数据；new可以分配任意类型的数据。

### select的用法

select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句select 机制用来处理异步 IO 问题，select 机制最大的一条限制就是每个 case 语句里必须是一个 IO 操作。常用于gorotine的完美退出

### channel的原理

```
   type hchanstruct {
 qcountuint// 队列中的总元素个数
 dataqsizuint// 环形队列大小，即可存放元素的个数
 bufunsafe.Pointer// 环形队列指针
 elemsize uint16//每个元素的大小
 closed   uint32//标识关闭状态
 elemtype *_type// 元素类型
 sendxuint// 发送索引，元素写入时存放到队列中的位置

 recvxuint// 接收索引，元素从队列的该位置读出
 recvq    waitq// 等待读消息的goroutine队列
 sendq    waitq// 等待写消息的goroutine队列lock mutex//互斥锁，chan不允许并发读写
}
```

- **读写流程**

**向 channel 写数据:**

若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。

若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。

若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。

**从 channel 读数据**

若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程。

如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程。

如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程。

将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒。

- **关闭 channel**

1.关闭 channel 时会将 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。

panic 出现的场景还有：

- 关闭值为 nil 的 channel
- 关闭已经关闭的 channel
- 向已经关闭的 channel 中写数据

### map原理

- map
- sync.map

### slice原理

### interface的结构

接口是其他类型可以实现的方法签名的集合。空接口。

### 关闭之后的channel能否读写

可以读，data变为该类型的零值，ok是false。但是不能写。

### context介绍

### 方法的接收者带指针和不带指针

当接收者为指针式，咱们能够经过方法改变该接收者的属性，非指针类型不能改变接收者属性。

### go mod解决版本依赖冲突

### go特性

### go锁原理

## K8S

### k8s的组件，介绍其中一个

k8s的节点主要分成两种类型，一种是承载控制面板的主节点，一种是运行用户实际部署应用的工作节点。

- 控制面板
  - k8sAPI服务器 负责控制面板其他组件以及工作节点通信
  - Scheculer 调度pod
  - Controller Manager 各种控制器（Replication、ReplicaSet、Deployment、StatefulSet、Node等等）执行各自的功能
  - etcd 持久化存储集群配置
- 工作节点
  - docker容器 运行应用的容器
  - kubelet 和API服务器通信，管理所在节点的容器
  - kube-proxy 负责组件之间的负载均衡网络流量

## Redis知识

## mysql知识

### mysql索引的结构

mysql索引的数据结构是B+树。叶子节点存储数据记录，非叶子节点存储键值对信息。聚集索引和辅助索引：聚集索引叶子节点存储整张表的行记录数据，辅助索引叶子节点存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。

### mysql联合索引

### mysql回表

### mysql事务机制及特性

### mysql分布式事务

### mysql死锁如何避免

## 其他

### linux如何查看占用内存最高的线程

top 或者ps -aux |sort -k4nr |head -K或者free  查看端口可以用lsof工具

### 判断链表是否闭环

可以用双指针遍历的方式。两个指针步长一个为1，一个为2。当两个指针指向的值一样，则链表闭环。

### 如何保证服务高可用

## 

