# interview summary

## go

### 内存逃逸

golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。

常见的内存逃逸场景：

- **在方法内将局部变量指针返回。**局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或者带指针的值到channel中。**在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- **在一个切片存储指针或者带指针的值。**一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在interface上调用方法。**在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

### GPM原理

之前的goroutine调度器是没有P的。M每次创建、调度、销毁G都要获取锁，形成了激烈的锁竞争；M 转移 G 会造成延迟和额外的系统负载；系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。

G：goroutine协程

P：processor处理器

M:：machine工作线程

go关键字会创建一个G，G优先保存到P的本地队列中，如果P的本地队列满了，则会保存到全局队列。M获取到P之后，会从P的本地队列弹出一个G执行，如果P的本地队列是空的，就从全局队列获取。如果全局队列获取不到，就会从其他的MP组合中偷取G过来执行。G如果创建了G'，是优先保存到同一个P的队列中的。如果M执行过程中G阻塞了，runtime就会将M跟P剥离，M进入休眠，获取其他的空闲线程或者创建线程来服务这个P。

GPM的调度策略：

- 复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
  
    1）work stealing 机制
    
     当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。
    
    2）hand off 机制
    
     当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。
    
- 利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。
- 抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。
- 全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。

### GC回收

常用的回收算法：

- 引用计数：每个对象维护一个引用计数，当被引用对象被创建或被赋值给其他对象时引用计数自动加 +1；如果这个对象被销毁，则计数 -1 ，当计数为 0 时，回收该对象。
    - 优点：对象可以很快被回收，不会出现内存耗尽或到达阀值才回收。
    - 缺点：不能很好的处理循环引用
- 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记“被引用”，没有被标记的则进行回收。
    - 优点：解决了引用计数的缺点。
    - 缺点：需要 STW（stop the world），暂时停止程序运行。
- 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。
    - 优点：回收性能好
    - 缺点：算法复杂

### 三色标记法

- 0初始状态下所有对象都是白色的。
- 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
- 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
- 循环步骤3，直到灰色对象全部变黑色。
- 通过写屏障(write-barrier)检测对象有变化，重复以上操作
- 收集所有白色对象（垃圾）

### 写屏障：

为了避免GC的过程中新修改的引用关系到GC的结果发生错误，我们需要进行STW。但是STW会影响程序的性能，所以我们要通过写屏障技术尽可能地缩短STW的时间。

写屏障破坏两个条件其一即可

- 破坏条件1：Dijistra写屏障

满足强三色不变性：黑色节点不允许引用白色节点 当黑色节点新增了白色节点的引用时，将对应的白色节点改为灰色

- 破坏条件2：Yuasa写屏障

满足弱三色不变性：黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用（确保不会被遗漏） 当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色

### STW（stop the world）

为了避免在 GC 的过程中，对象之间的引用关系发生新的变更，使得GC的结果发生错误（如GC过程中新增了一个引用，但是由于未扫描到该引用导致将被引用的对象清除了），停止所有正在运行的协程。Golang目前已经可以做到1ms以下的STW。

### CSP模型

CSP 模型是“以通信的方式来共享内存”，不同于传统的多线程通过共享内存来通信。用于描述两个独立的并发实体通过共享的通讯 channel (管道)进行通信的并发模型。

### waitgroup使用场景

实现goroutine的同步，并发控制。可以设置最大goroutine数。

- Add(delta int)：增加/减少若干计数
- Done：减少 1 个计数，等价于 **Add(-1)**
- Wait：卡住，直到计数等于 0

### make和new的区别

Go语言中new和make都是用来内存分配的。简单的说，new只分配内存，make用于slice，map，和channel的初始化。

- make和new都是golang用来分配内存的，且在堆上分配内存，make 即分配内存，也初始化内存。new只是将内存清零，并没有初始化内存。
- make返回的还是引用类型本身；而new返回的是指向类型的指针。
- make只能用来分配及初始化类型为slice，map，channel的数据；new可以分配任意类型的数据。

### select的用法

select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句select 机制用来处理异步 IO 问题，select 机制最大的一条限制就是每个 case 语句里必须是一个 IO 操作。常用于gorotine的完美退出

### channel的原理

```
   type hchanstruct {
 qcountuint// 队列中的总元素个数
 dataqsizuint// 环形队列大小，即可存放元素的个数
 bufunsafe.Pointer// 环形队列指针
 elemsize uint16//每个元素的大小
 closed   uint32//标识关闭状态
 elemtype *_type// 元素类型
 sendxuint// 发送索引，元素写入时存放到队列中的位置

 recvxuint// 接收索引，元素从队列的该位置读出
 recvq    waitq// 等待读消息的goroutine队列
 sendq    waitq// 等待写消息的goroutine队列lock mutex//互斥锁，chan不允许并发读写
}
```

- **读写流程**

**向 channel 写数据:**

若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。

若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。

若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。

**从 channel 读数据**

若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程。

如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程。

如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程。

将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒。

- **关闭 channel**

1.关闭 channel 时会将 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。

panic 出现的场景还有：

- 关闭值为 nil 的 channel
- 关闭已经关闭的 channel
- 向已经关闭的 channel 中写数据

### map原理

- map

  哈希碰撞就是不同的键通过哈希算法可能产生相同的值。避免哈希碰撞的策略主要有两种：拉链法和开放寻址法。go采用的是拉链法。将同一个桶中的元素通过链表的形式形成链接。随着桶中元素的增加，可以不断链接新的元素，同时不用预先为元素分配内存。它的不足之处在于它需要存储额外的指针用于链接元素，增加了整个哈希表的大小。同时由于链表存储的地址不连续，所以无法高效地利用CPU高速缓存。Go语言中的哈希表采用的是优化的拉链法，每一个桶中存储了8个元素用于加速访问。

- sync.map

  map并不支持并发的读写。如果有业务需求也可以通过各种方法来实现。主要思路是通过加锁保证每个协程同步操作内存。

  - 加锁 互斥锁`sync.Mutex`  读写锁`sync.RwMutex`

  - 利用channel

  - 使用`sync.map`。标准库中的`sync.Map`是专为`append-only`场景设计的。`sync.Map`在读多写少性能比较好，否则并发性能很差

    ```go
    // 写操作 
    m.Store(key, value) 
    // 读操作 
    value, ok := m.Load(key)
    ```

  - 使用第三方包的map。例如：`concurrent-map`提供了一种高性能的解决方案:通过对内部`map`进行分片，降低锁粒度，从而达到最少的锁等待时间(锁冲突)

### slice原理

slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。切片是长度可变的序列，序列中的每个元素都有相同的类型。它和数组不同的是切片不需要指定长度。切片是一种轻量级的数据结构，提供了访问数组任意元素的功能。

```go
1. 切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。
2. 切片的长度可以改变，因此，切片是一个可变的数组。
3. 切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 
4. cap可以求出slice最大扩张容量，不能超出数组限制。0 <= len(slice) <= len(array)，其中array是slice引用的数组。
5. 切片的定义：var 变量名 []类型，比如 var str []string  var arr []int。
6. 如果 slice == nil，那么 len、cap 结果都等于 0。
```

append函数可以添加新元素到切片的末尾，它可以接受可变长度的元素，并且可以自动扩容。

切片的扩容策略：

如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。上面那个例子也验证了这一情况，总容量从原来的4个翻倍到现在的8个。

一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每 次增加原来容量的四分之一。

注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。

### interface的结构

接口是其他类型可以实现的方法签名的集合。空接口。

### 关闭之后的channel能否读写

可以读，data变为该类型的零值，ok是false。但是不能写。

### context介绍

为了能够优雅的管理协程的退出，特别是多个协程甚至网络服务之间的退出，Go引入了context包。

context很大程度上利用了通道在close时会通知所有监听它的协程这一特性。

* Background()主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。
* TODO()，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个。

* WithCancel函数返回一个子context并且有cancel退出方法。子context调用cancel方法或者父context退出时都会退出。
* WithTimeout函数指定超时时间，当超时发生后，子context会退出。
* WithDeadline和WithTimeout处理方法相似。参数指的是最后到期的时间。 
* WithValue函数返回带key-value的子context。

background和todo本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。

WithCancel或WithTimeout函数会产生一个子context结构cancelCtx，并保留了父context的信息。children字段保存当前context之后派生的子context的信息。每个context都会有一个新的通道，这保证了子context的退出不会影响父context。

### 方法的接收者带指针和不带指针

当接收者为指针式，咱们能够经过方法改变该接收者的属性，非指针类型不能改变接收者属性。

### go mod解决版本依赖冲突

1. **确定问题**：首先，你需要确定具体是哪些包的哪些版本引发了冲突。这可以通过查看构建日志，或者使用 `go list -m all` 命令查看所有依赖和它们的版本来完成。
2. **升级或降级依赖**：冲突通常由于使用了不兼容的依赖版本引起。在这种情况下，你可能需要升级或降级一个或多个依赖。这可以通过 `go get` 命令完成，例如 `go get github.com/some/dependency@v1.2.3` 将会更新你的项目到指定的依赖版本。
3. **版本选择**：在某些情况下，你可能需要手动指定依赖的版本。这可以通过编辑 `go.mod` 文件来完成。在 `go.mod` 文件中，你可以为每个依赖指定一个版本号，例如 `github.com/some/dependency v1.2.3`。
4. **使用 replace 指令**：如果你不能更改依赖的版本，因为它是由你的依赖所要求的，那么你可以使用 `replace` 指令。这将允许你重定向一个依赖到另一个版本或替代模块。例如，`replace github.com/some/dependency => github.com/some/dependency v1.2.3`。
5. **清理并验证**：在解决了依赖冲突后，你可以使用 `go mod tidy` 命令清理未使用的依赖，并确保你的 `go.mod` 和 `go.sum` 文件是最新的。此外，你可以使用 `go build` 或 `go test` 命令来验证你的解决方案是否有效。

### go特性

Go 语言是一种静态类型、编译型、并发性的编程语言，由 Google 设计和开发。适合开发高性能的网络服务，数据管道，命令行工具等多种应用程序。

1. **简洁，易于理解和编写**：Go 语言的语法非常简洁，这使得编写和阅读 Go 代码变得容易。Go 语言减少了许多传统编程语言中的冗余元素（如分号和括号），这使得 Go 代码更加简洁。
2. **垃圾收集**：Go 语言有内置的垃圾收集机制，这大大简化了内存管理，帮助开发者避免了许多常见的内存泄漏问题。
3. **原生支持并发**：Go 语言在语言级别上支持并发编程，主要通过 goroutines 和 channels 两个特性来实现。goroutines 类似于轻量级的线程，channels 则用于 goroutines 之间的通信。这使得在 Go 中编写高并发程序变得简单和直观。
4. **静态类型系统**：Go 是一种静态类型的编程语言，这意味着类型在编译时就已经确定，能够提前发现很多类型错误。
5. **快速编译**：Go 语言具有非常快速的编译速度，即使在大型项目中也能快速地完成编译。
6. **标准库丰富**：Go 语言的标准库提供了许多常用功能，如 HTTP 服务和客户端、JSON/XML 解析、SQL 数据库和许多其他功能。
7. **跨平台编译**：Go 支持跨平台编译，可以轻易地为不同的操作系统和体系结构构建程序。
8. **面向接口的编程**：Go 语言的接口类型提供了一种方式，使得不同的类型可以有相同的行为。这使得 Go 语言能够在没有泛型的情况下，实现一种类似于“鸭子类型”的功能。
9. **工具链**：Go 语言提供了一整套工具链，包括用于获取、构建、测试和分析代码的工具。
10. **Go Modules**：从 Go 1.11 开始，Go 语言引入了模块（Modules）系统，使得依赖管理变得更加方便和直观。

### go锁原理	

Go 语言的锁主要是通过 底层的原子锁以及sync 包中的 Mutex（互斥锁）和 RWMutex（读写锁）实现的。

#### 原子锁

针对基本数据类型（布尔型数据、整型、浮点型、字符串）我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库`sync/atomic`提供。原子锁是底层最基础的同步保证，通过原子操作可以构建起许多同步原语，例如自旋锁、信号量、互斥锁等。

#### 互斥锁

互斥锁是一种混合锁，其实现方式包含了自旋锁，同时参考了操作系统锁的实现。Mutex包含了锁的状态state及信号量sema。

Mutex 的主要作用是保证同时只有一个 goroutine 能访问某个资源。它包含两种状态，即锁定（Locked）和未锁定（Unlocked）。当一个 goroutine 尝试获取一个已经被其他 goroutine 锁定的 Mutex 时，这个 goroutine 就会被阻塞，直到锁被释放。

Mutex 的内部实现使用了“自旋锁”和“睡眠”两种方式来保证公平性和效率。当一个 goroutine 尝试获取一个已经锁定的锁时，它首先会进行几次自旋（即快速重复检查锁是否被释放，而不进入睡眠状态）。如果在自旋期间锁被释放，那么 goroutine 可以立即获取到锁，从而避免了系统线程切换的开销。但如果自旋结束后锁仍未被释放，那么 goroutine 就会进入睡眠状态，直到被唤醒。

#### 读写锁

RWMutex 是一个读/写互斥锁。相比于 Mutex，它更加灵活，因为它允许多个 goroutine 同时读取某个资源，但是在写入资源时，它只允许一个 goroutine 访问，而且优先考虑写入的 goroutine。读锁必须能观察到上一次写锁写入的值，写锁要等待之前的读锁释放才能写入。读可以有多个协程同时读，但是写只能有一个协程同时写。

* 读锁

  读取操作先通过原子操作将readerCount加1，如果readerCount≥0就直接返回，所以如果只是获取读取锁的操作，那么其成本只有一个原子操作。如果readerCount＜0，说明当前有写锁，当前协程将借助信号量陷入等待状态，如果获取到信号量则立即退出，没有获取到信号量时的逻辑与互斥锁逻辑类似。

  

  读锁解锁时，如果当前没有写锁，则其成本只有一个原子操作并直接退出。如果当前有写锁在等待，则调用rUnlockSlow判断当前是否最后一个被释放的读锁，如果是则需要增加信号量并唤醒写锁。

* 写锁

  读写锁申请写锁时要调用Lock方法，必须先获取互斥锁，因为它复用了互斥锁的功能。接着readerCount减去rwmutexMaxReaders阻止后续的读操作。如果当前有其他的G持有互斥锁的读锁，那么当前协程会加入全局等待队列并进入休眠状态，当最后一个读锁被释放时，会唤醒该协程。

  

  解锁时，调用Unlock方法。将readerCount加上rwmutexMaxReaders，表示不会堵塞后续的读锁，依次唤醒所有等待中的读锁。当所有读锁唤醒完毕后会释放互斥锁。

所以读写锁在写操作时的性能和互斥锁类似，但是在只有读操作时效率会高很多，因为读锁可以被多个协程获取。

## K8S

### k8s的组件，介绍其中一个

k8s的节点主要分成两种类型，一种是承载控制面板的主节点，一种是运行用户实际部署应用的工作节点。

- 控制面板
  - k8sAPI服务器 负责控制面板其他组件以及工作节点通信
  - Scheculer 调度pod
  - Controller Manager 各种控制器（Replication、ReplicaSet、Deployment、StatefulSet、Node等等）执行各自的功能
  - etcd 持久化存储集群配置
- 工作节点
  - docker容器 运行应用的容器
  - kubelet 和API服务器通信，管理所在节点的容器
  - kube-proxy 负责组件之间的负载均衡网络流量

## Redis知识

## mysql知识

### mysql索引的结构

mysql索引的数据结构是B+树。叶子节点存储数据记录，非叶子节点存储键值对信息。聚集索引和辅助索引：聚集索引叶子节点存储整张表的行记录数据，辅助索引叶子节点存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。

### mysql联合索引

联合索引（也被称为复合索引或多列索引）是数据库中的一个重要概念，它允许你在一个索引中包含两个或更多的列，以便提高查询性能。

1. **索引顺序的重要性**：在联合索引中，列的顺序非常重要。在同一个联合索引中，位于前面的列会先于后面的列被索引。因此，对于位于前面的列进行的搜索会更快。此外，你只能在已经使用了前面的列的条件下，才能在 WHERE 子句中有效地使用联合索引中的后续列。
2. **最左前缀原则**：MySQL 中的联合索引遵循最左前缀原则。这意味着你可以只用到联合索引中的一部分，只要你使用的部分是从最左边开始的连续列。例如，如果你有一个包含 `last_name`、`first_name` 和 `dob` 列的联合索引，那么你可以在查询中只使用 `last_name` 列或者 `last_name` 和 `first_name` 列，但是你不能只使用 `first_name` 列或者 `dob` 列。
3. **排序和分组**：除了提高查询性能外，联合索引还可以提高排序和分组的性能。如果你的查询中的 ORDER BY 或 GROUP BY 子句使用的列是联合索引的一部分，那么 MySQL 可能会使用索引来加速排序或分组操作。

索引失效的情况：

1. **非最左前缀查询**：MySQL 的联合索引遵循最左前缀原则，这意味着查询中的字段必须从索引的最左边开始并连续向右进行。例如，如果我们有一个 `(A, B, C)` 的联合索引，查询条件只包含 `B` 或 `C`，或者只包含 `A` 和 `C`，联合索引就不会被有效使用。
2. **使用了不等于操作符**：如果查询中使用了 `!=` 或 `<>` 操作符，那么即使查询条件从最左列开始，联合索引也可能不会被使用。
3. **使用了 OR 操作符**：如果 WHERE 子句中使用了 OR 操作符连接多个条件，那么联合索引可能会失效。因为 OR 操作符可能会使得索引的部分列被忽略。
4. **LIKE 操作符以通配符开始**：如果 LIKE 操作符的模式以 `%` 开头，那么即使 LIKE 操作符作用的列是联合索引的最左列，索引也可能不会被使用。mysql索引失效会变成全表扫描的操作。
5. **函数或表达式作用于索引列**：如果查询条件中的索引列被函数或表达式包含，例如 `WHERE YEAR(date) = 2023`，那么 MySQL 可能无法使用索引。
6. **类型隐式转换**：如果查询条件中的数据类型与索引列的数据类型不一致，需要进行隐式数据类型转换，那么索引可能无法被使用。

### mysql回表

回表发生在索引查找后，数据库还需要再次访问主表（或数据表）以获取更多信息的情况。在数据库中，索引通常只包含一部分列的数据。当你查询的列全部包含在索引中时，数据库可以直接从索引中返回结果，这种情况称为 "覆盖索引查询"（Covering Index Query）。然而，当查询的列并非全部包含在索引中时，数据库需要先通过索引定位到数据，然后再次访问主表（或数据表）以获取查询的其他列的数据，这个过程就叫做 "回表"。

回表操作会增加 I/O 开销，因此可能会影响查询性能。为了避免回表，可以尽量设计覆盖索引，也就是尽量使查询的列全部包含在索引中。但同时也要注意，过多的覆盖索引会消耗更多的存储空间，并且可能会影响数据修改（如 INSERT、UPDATE、DELETE）的性能。

### mysql死锁如何避免

1. **按照固定的顺序请求资源**：当你需要在一个事务中锁定多个行或表时，总是按照相同的顺序请求锁定。这样可以避免两个事务以不同的顺序锁定资源，从而引发死锁。
2. **使用小的事务**：避免使用长时间的事务，长时间持有锁会增加死锁的机会。尽量将事务保持在一个合理的大小，并尽快提交事务以释放锁。
3. **在代码中处理死锁**：Go 语言可以使用 `sql.DB` 的 `Ping`、`Exec`、`Query` 和 `Prepare` 方法返回的错误进行死锁检测。你可以在程序中捕获这些错误，然后重新尝试事务。
4. **减少锁定的行数**：尽可能减少锁定的行数，仅在必要时锁定行。
5. **不要在事务中有用户交互**：避免在事务处理过程中有用户交互或其他可能阻塞事务的操作，以减少事务的执行时间，降低死锁的可能性。

### mysql事务机制及特性

### mysql分布式事务



## 其他

### linux如何查看占用内存最高的线程

top 或者ps -aux |sort -k4nr |head -K或者free  查看端口可以用lsof工具

### 判断链表是否闭环

可以用双指针遍历的方式。两个指针步长一个为1，一个为2。当两个指针指向的值一样，则链表闭环。

### 如何保证服务高可用

## 

